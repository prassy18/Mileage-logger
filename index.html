<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Family Tree App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 1rem;
            text-align: center;
        }

        .tabs {
            display: flex;
            background: #34495e;
            overflow-x: auto;
        }

        .tab {
            flex: 1;
            min-width: 120px;
            padding: 1rem;
            background: #34495e;
            color: white;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
            white-space: nowrap;
        }

        .tab:hover {
            background: #3d566e;
        }

        .tab.active {
            background: #2980b9;
        }

        .tab-content {
            display: none;
            padding: 2rem;
            min-height: calc(100vh - 120px);
        }

        .tab-content.active {
            display: block;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: #3498db;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.3s;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .btn:hover {
            background: #2980b9;
        }

        .btn-secondary {
            background: #95a5a6;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn-danger {
            background: #e74c3c;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .tree-container {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 2rem;
            overflow: auto;
            min-height: 600px;
        }

        .tree-canvas {
            position: relative;
            min-width: 100%;
            min-height: 500px;
        }

        .tree-node {
            position: absolute;
            background: white;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 1rem;
            min-width: 180px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .tree-node:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .tree-node.focused {
            border-color: #e74c3c;
            box-shadow: 0 0 0 3px rgba(231, 76, 60, 0.2);
        }

        .tree-node.root-ancestor {
            border-color: #f39c12;
            background: #fef9e7;
        }

        .tree-node h4 {
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .tree-node p {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin: 0.25rem 0;
        }

        .tree-connection {
            position: absolute;
            background: #3498db;
            z-index: 1;
        }

        .spouse-connection {
            background: #e74c3c;
        }

        .parent-child-connection {
            background: #2ecc71;
        }

        .relationships-container {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 2rem;
        }

        .relationship-section {
            margin-bottom: 2rem;
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .relationship-section h3 {
            color: #2c3e50;
            margin-bottom: 1rem;
            border-bottom: 2px solid #3498db;
            padding-bottom: 0.5rem;
        }

        .person-card {
            background: #ecf0f1;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 0.5rem;
        }

        .person-card h4 {
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .tree-list {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 2rem;
        }

        .tree-item {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tree-item.active {
            border-left: 4px solid #3498db;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }

        .modal-content {
            background: white;
            margin: 5% auto;
            padding: 2rem;
            border-radius: 12px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #999;
        }

        .spouse-group {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin-right: 0.5rem;
        }

        @media (max-width: 768px) {
            .tabs {
                font-size: 0.9rem;
            }
            
            .tab {
                min-width: 100px;
                padding: 0.75rem 0.5rem;
            }
            
            .tab-content {
                padding: 1rem;
            }
            
            .tree-container {
                padding: 1rem;
            }
            
            .tree-node {
                min-width: 160px;
                padding: 0.75rem;
            }
            
            .modal-content {
                margin: 10% 1rem;
                padding: 1.5rem;
            }
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border: 1px solid #c3e6cb;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Family Tree Manager</h1>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('tree-view')">Tree View</button>
            <button class="tab" onclick="showTab('add-person')">Add Person</button>
            <button class="tab" onclick="showTab('find-relations')">Find Relations</button>
            <button class="tab" onclick="showTab('manage-trees')">Manage Trees</button>
            <button class="tab" onclick="showTab('save-load')">Save/Load</button>
        </div>

        <!-- Tree View Tab -->
        <div id="tree-view" class="tab-content active">
            <div class="tree-search">
                <div class="form-group">
                    <label for="tree-search-input">Search Person (to focus on them):</label>
                    <input type="text" id="tree-search-input" placeholder="Enter person's name..." style="max-width: 300px;">
                    <button class="btn" onclick="focusOnPerson()">Focus</button>
                    <button class="btn btn-secondary" onclick="showFullTree()">Show Full Tree</button>
                </div>
            </div>
            <div class="tree-container" id="tree-display">
                <div class="tree-canvas" id="tree-canvas">
                    <p>No family tree data available. Add some family members first!</p>
                </div>
            </div>
        </div>

        <!-- Add Person Tab -->
        <div id="add-person" class="tab-content">
            <h2>Add New Family Member</h2>
            <div id="add-person-message"></div>
            
            <div class="form-group">
                <label for="person-name">Name *</label>
                <input type="text" id="person-name" required>
            </div>
            
            <div class="form-group">
                <label for="birth-year">Year of Birth</label>
                <input type="text" id="birth-year" placeholder="e.g., 1980, early 1800s, unknown">
            </div>
            
            <div class="form-group">
                <label for="death-year">Year of Death</label>
                <input type="text" id="death-year" placeholder="e.g., 2020, early 1900s, unknown">
            </div>
            
            <div class="form-group">
                <label for="gothram">Gothram</label>
                <input type="text" id="gothram">
            </div>
            
            <div class="form-group">
                <label for="sex">Sex</label>
                <select id="sex">
                    <option value="">Select...</option>
                    <option value="Male">Male</option>
                    <option value="Female">Female</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="birthplace">Birthplace</label>
                <input type="text" id="birthplace">
            </div>
            
            <div class="form-group">
                <label for="occupation">Occupation</label>
                <input type="text" id="occupation">
            </div>
            
            <div class="form-group">
                <label for="notes">Notes</label>
                <textarea id="notes" placeholder="Additional information about this person..."></textarea>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="is-alive">
                <label for="is-alive">This person is still alive</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="is-root-ancestor">
                <label for="is-root-ancestor">Mark as oldest known ancestor (tree root)</label>
            </div>

            <!-- Parents Selection -->
            <h3>Parents</h3>
            <div class="form-group">
                <label for="father">Father</label>
                <select id="father">
                    <option value="">Select father or leave blank if unknown</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="mother">Mother</label>
                <select id="mother">
                    <option value="">Select mother or leave blank if unknown</option>
                </select>
            </div>

            <!-- Spouses Section -->
            <h3>Spouse(s)</h3>
            <div id="spouses-container">
                <div class="spouse-group">
                    <div class="form-group">
                        <label>Spouse</label>
                        <select class="spouse-select">
                            <option value="">Select spouse or leave blank</option>
                        </select>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" class="unknown-spouse">
                        <label>Unknown spouse (name not known)</label>
                    </div>
                </div>
            </div>
            <button type="button" class="btn btn-secondary" onclick="addSpouseField()">Add Another Spouse</button>

            <div style="margin-top: 2rem;">
                <button class="btn" onclick="addPerson()">Add Person</button>
                <button class="btn btn-secondary" onclick="clearPersonForm()">Clear Form</button>
            </div>
        </div>

        <!-- Find Relations Tab -->
        <div id="find-relations" class="tab-content">
            <h2>Find Family Relations</h2>
            
            <div class="form-group">
                <label for="relation-search">Select Person:</label>
                <select id="relation-search">
                    <option value="">Choose a person...</option>
                </select>
                <button class="btn" onclick="showRelations()">Show Relations</button>
            </div>
            
            <div class="relationships-container" id="relations-display">
                <p>Select a person to see their family relationships.</p>
            </div>
        </div>

        <!-- Manage Trees Tab -->
        <div id="manage-trees" class="tab-content">
            <h2>Manage Family Trees</h2>
            <div id="manage-trees-message"></div>
            
            <div class="form-group">
                <label for="new-tree-name">Create New Tree:</label>
                <input type="text" id="new-tree-name" placeholder="Enter tree name...">
                <button class="btn" onclick="createNewTree()">Create Tree</button>
            </div>

            <h3>Existing Trees</h3>
            <div class="tree-list" id="trees-list">
                <p>No trees created yet.</p>
            </div>

            <h3>Link Trees</h3>
            <div class="form-group">
                <label for="link-person-name">Search for person across all trees:</label>
                <input type="text" id="link-person-name" placeholder="Enter person's name...">
                <button class="btn" onclick="searchAcrossTrees()">Search</button>
            </div>
            <div id="link-results"></div>
        </div>

        <!-- Save/Load Tab -->
        <div id="save-load" class="tab-content">
            <h2>Save & Load Data</h2>
            <div id="save-load-message"></div>
            
            <h3>Export Data</h3>
            <p>Save your family tree data to a file on your device.</p>
            <button class="btn" onclick="exportData()">Export Current Tree</button>
            <button class="btn" onclick="exportAllData()">Export All Trees</button>

            <h3>Import Data</h3>
            <p>Load previously saved family tree data.</p>
            <div class="form-group">
                <label for="import-file">Choose file:</label>
                <input type="file" id="import-file" accept=".json">
                <button class="btn" onclick="importData()">Import Data</button>
            </div>

            <h3>Clear Data</h3>
            <p>⚠️ This will permanently delete all your family tree data.</p>
            <button class="btn btn-danger" onclick="clearAllData()">Clear All Data</button>
        </div>
    </div>

    <!-- Person Details Modal -->
    <div id="person-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Person Details</h3>
                <button class="close" onclick="closeModal()">&times;</button>
            </div>
            <div id="person-details">
                <!-- Person details will be populated here -->
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let familyTrees = {};
        let currentTreeId = null;
        let focusedPersonId = null;

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            loadFromLocalStorage();
            if (Object.keys(familyTrees).length === 0) {
                createNewTree('My Family Tree');
            } else {
                currentTreeId = Object.keys(familyTrees)[0];
            }
            updateUI();
        });

        // Tab management
        function showTab(tabId) {
            // Hide all tabs
            const tabs = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            const tabButtons = document.querySelectorAll('.tab');
            tabButtons.forEach(btn => btn.classList.remove('active'));
            
            // Show selected tab
            document.getElementById(tabId).classList.add('active');
            event.target.classList.add('active');
            
            // Update content based on tab
            if (tabId === 'tree-view') {
                renderTree();
            } else if (tabId === 'add-person') {
                updatePersonFormDropdowns();
            } else if (tabId === 'find-relations') {
                updateRelationDropdown();
            } else if (tabId === 'manage-trees') {
                updateTreesList();
            }
        }

        // Tree management
        function createNewTree(name = '') {
            if (!name) {
                name = document.getElementById('new-tree-name').value.trim();
                if (!name) {
                    showMessage('manage-trees-message', 'Please enter a tree name.', 'error');
                    return;
                }
            }
            
            const treeId = 'tree_' + Date.now();
            familyTrees[treeId] = {
                id: treeId,
                name: name,
                people: {},
                relationships: {},
                rootAncestorId: null
            };
            
            currentTreeId = treeId;
            document.getElementById('new-tree-name').value = '';
            showMessage('manage-trees-message', `Tree "${name}" created successfully!`, 'success');
            updateTreesList();
            saveToLocalStorage();
        }

        function switchTree(treeId) {
            currentTreeId = treeId;
            focusedPersonId = null;
            updateUI();
            showMessage('manage-trees-message', `Switched to "${familyTrees[treeId].name}"`, 'success');
        }

        function deleteTree(treeId) {
            if (confirm(`Are you sure you want to delete "${familyTrees[treeId].name}"?`)) {
                delete familyTrees[treeId];
                
                if (currentTreeId === treeId) {
                    const remainingTrees = Object.keys(familyTrees);
                    currentTreeId = remainingTrees.length > 0 ? remainingTrees[0] : null;
                    
                    if (!currentTreeId) {
                        createNewTree('My Family Tree');
                    }
                }
                
                updateUI();
                saveToLocalStorage();
                showMessage('manage-trees-message', 'Tree deleted successfully.', 'success');
            }
        }

        // Person management
        function addPerson() {
            const name = document.getElementById('person-name').value.trim();
            if (!name) {
                showMessage('add-person-message', 'Name is required.', 'error');
                return;
            }

            const personId = 'person_' + Date.now();
            const currentTree = familyTrees[currentTreeId];
            const gothram = document.getElementById('gothram').value.trim();
            const isAlive = document.getElementById('is-alive').checked;
            const isRootAncestor = document.getElementById('is-root-ancestor').checked;
            
            // Create person object
            const person = {
                id: personId,
                name: name,
                birthYear: document.getElementById('birth-year').value.trim(),
                deathYear: isAlive ? '' : document.getElementById('death-year').value.trim(),
                gothram: gothram,
                sex: document.getElementById('sex').value,
                birthplace: document.getElementById('birthplace').value.trim(),
                occupation: document.getElementById('occupation').value.trim(),
                notes: document.getElementById('notes').value.trim(),
                isAlive: isAlive,
                isRootAncestor: isRootAncestor
            };

            // Add person to tree
            currentTree.people[personId] = person;

            // Handle root ancestor
            if (isRootAncestor) {
                // Remove root ancestor flag from other people
                Object.values(currentTree.people).forEach(p => {
                    if (p.id !== personId) {
                        p.isRootAncestor = false;
                    }
                });
                currentTree.rootAncestorId = personId;
                
                // Auto-name tree if it's the default name and gothram exists
                if (currentTree.name === 'My Family Tree' && gothram) {
                    currentTree.name = `${gothram} Family Tree`;
                }
            }

            // Handle relationships
            const fatherId = document.getElementById('father').value;
            const motherId = document.getElementById('mother').value;

            if (fatherId) {
                addRelationship(fatherId, personId, 'parent-child');
            }
            if (motherId) {
                addRelationship(motherId, personId, 'parent-child');
            }

            // Handle spouses
            const spouseSelects = document.querySelectorAll('.spouse-select');
            const unknownSpouseCheckboxes = document.querySelectorAll('.unknown-spouse');
            
            spouseSelects.forEach((select, index) => {
                const spouseId = select.value;
                const isUnknownSpouse = unknownSpouseCheckboxes[index].checked;
                
                if (spouseId) {
                    addRelationship(personId, spouseId, 'spouse');
                } else if (isUnknownSpouse) {
                    // Create unknown spouse
                    const unknownSpouseId = 'person_' + Date.now() + '_unknown';
                    const unknownSpouse = {
                        id: unknownSpouseId,
                        name: 'Unknown Spouse',
                        birthYear: '',
                        deathYear: '',
                        gothram: gothram, // Use same gothram or could be different
                        sex: person.sex === 'Male' ? 'Female' : 'Male',
                        birthplace: '',
                        occupation: '',
                        notes: 'Spouse name unknown',
                        isAlive: false,
                        isRootAncestor: false
                    };
                    currentTree.people[unknownSpouseId] = unknownSpouse;
                    addRelationship(personId, unknownSpouseId, 'spouse');
                }
            });

            saveToLocalStorage();
            clearPersonForm();
            showMessage('add-person-message', `${name} added successfully!`, 'success');
            updatePersonFormDropdowns();
        }

        function addRelationship(person1Id, person2Id, type) {
            const currentTree = familyTrees[currentTreeId];
            if (!currentTree.relationships[person1Id]) {
                currentTree.relationships[person1Id] = [];
            }
            if (!currentTree.relationships[person2Id]) {
                currentTree.relationships[person2Id] = [];
            }

            // Add relationship both ways
            currentTree.relationships[person1Id].push({
                personId: person2Id,
                type: type
            });

            if (type === 'parent-child') {
                currentTree.relationships[person2Id].push({
                    personId: person1Id,
                    type: 'child-parent'
                });
            } else if (type === 'spouse') {
                currentTree.relationships[person2Id].push({
                    personId: person1Id,
                    type: 'spouse'
                });
            }
        }

        function addSpouseField() {
            const container = document.getElementById('spouses-container');
            const spouseGroup = document.createElement('div');
            spouseGroup.className = 'spouse-group';
            spouseGroup.innerHTML = `
                <div class="form-group">
                    <label>Spouse</label>
                    <select class="spouse-select">
                        <option value="">Select spouse or leave blank</option>
                    </select>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" class="unknown-spouse">
                    <label>Unknown spouse (name not known)</label>
                </div>
                <button type="button" class="btn btn-danger" onclick="this.parentElement.remove()">Remove</button>
            `;
            container.appendChild(spouseGroup);
            updateSpouseDropdowns();
        }

        function clearPersonForm() {
            document.getElementById('person-name').value = '';
            document.getElementById('birth-year').value = '';
            document.getElementById('death-year').value = '';
            document.getElementById('gothram').value = '';
            document.getElementById('sex').value = '';
            document.getElementById('birthplace').value = '';
            document.getElementById('occupation').value = '';
            document.getElementById('notes').value = '';
            document.getElementById('is-alive').checked = false;
            document.getElementById('is-root-ancestor').checked = false;
            document.getElementById('father').value = '';
            document.getElementById('mother').value = '';
            
            // Reset spouses to single field
            const spousesContainer = document.getElementById('spouses-container');
            spousesContainer.innerHTML = `
                <div class="spouse-group">
                    <div class="form-group">
                        <label>Spouse</label>
                        <select class="spouse-select">
                            <option value="">Select spouse or leave blank</option>
                        </select>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" class="unknown-spouse">
                        <label>Unknown spouse (name not known)</label>
                    </div>
                </div>
            `;
            updatePersonFormDropdowns();
        }

        // UI update functions
        function updateUI() {
            updatePersonFormDropdowns();
            updateRelationDropdown();
            updateTreesList();
            renderTree();
        }

        function updatePersonFormDropdowns() {
            if (!currentTreeId || !familyTrees[currentTreeId]) return;
            
            const currentTree = familyTrees[currentTreeId];
            const people = Object.values(currentTree.people);
            
            // Update father dropdown
            const fatherSelect = document.getElementById('father');
            fatherSelect.innerHTML = '<option value="">Select father or leave blank if unknown</option>';
            people.filter(p => p.sex === 'Male').forEach(person => {
                fatherSelect.innerHTML += `<option value="${person.id}">${person.name}</option>`;
            });
            
            // Update mother dropdown
            const motherSelect = document.getElementById('mother');
            motherSelect.innerHTML = '<option value="">Select mother or leave blank if unknown</option>';
            people.filter(p => p.sex === 'Female').forEach(person => {
                motherSelect.innerHTML += `<option value="${person.id}">${person.name}</option>`;
            });

            updateSpouseDropdowns();
        }

        function updateSpouseDropdowns() {
            if (!currentTreeId || !familyTrees[currentTreeId]) return;
            
            const currentTree = familyTrees[currentTreeId];
            const people = Object.values(currentTree.people);
            
            const spouseSelects = document.querySelectorAll('.spouse-select');
            spouseSelects.forEach(select => {
                select.innerHTML = '<option value="">Select spouse or leave blank</option>';
                people.forEach(person => {
                    select.innerHTML += `<option value="${person.id}">${person.name}</option>`;
                });
            });
        }

        function updateRelationDropdown() {
            if (!currentTreeId || !familyTrees[currentTreeId]) return;
            
            const currentTree = familyTrees[currentTreeId];
            const people = Object.values(currentTree.people);
            
            const relationSelect = document.getElementById('relation-search');
            relationSelect.innerHTML = '<option value="">Choose a person...</option>';
            people.forEach(person => {
                relationSelect.innerHTML += `<option value="${person.id}">${person.name}</option>`;
            });
        }

        function updateTreesList() {
            const container = document.getElementById('trees-list');
            if (Object.keys(familyTrees).length === 0) {
                container.innerHTML = '<p>No trees created yet.</p>';
                return;
            }

            let html = '';
            Object.values(familyTrees).forEach(tree => {
                html += `
                    <div class="tree-item ${tree.id === currentTreeId ? 'active' : ''}">
                        <div>
                            <h4>${tree.name}</h4>
                            <p>${Object.keys(tree.people).length} people</p>
                        </div>
                        <div>
                            ${tree.id !== currentTreeId ? `<button class="btn" onclick="switchTree('${tree.id}')">Switch</button>` : '<span class="btn">Current</span>'}
                            <button class="btn btn-danger" onclick="deleteTree('${tree.id}')">Delete</button>
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        // Tree visualization
        function renderTree() {
            const container = document.getElementById('tree-canvas');
            if (!currentTreeId || !familyTrees[currentTreeId]) {
                container.innerHTML = '<p>No family tree data available. Add some family members first!</p>';
                return;
            }

            const currentTree = familyTrees[currentTreeId];
            const people = currentTree.people;
            const relationships = currentTree.relationships;

            if (Object.keys(people).length === 0) {
                container.innerHTML = '<p>No family members in this tree yet. Add some people first!</p>';
                return;
            }

            // Build tree structure with improved root finding
            const treeStructure = buildTreeStructure(people, relationships);
            
            // Clear container
            container.innerHTML = '';

            // Calculate positions and render
            const positions = calculateTreePositions(treeStructure, people);
            renderTreeNodes(container, positions, people, treeStructure);
            renderConnections(container, positions, treeStructure);
        }

        function buildTreeStructure(people, relationships) {
            const structure = {
                roots: [],
                children: {},
                parents: {},
                spouses: {},
                levels: {}
            };

            // Initialize structure for each person
            Object.keys(people).forEach(personId => {
                structure.children[personId] = [];
                structure.parents[personId] = [];
                structure.spouses[personId] = [];
            });

            // Build relationships
            Object.keys(relationships).forEach(personId => {
                if (relationships[personId]) {
                    relationships[personId].forEach(rel => {
                        if (rel.type === 'parent-child') {
                            if (!structure.children[personId].includes(rel.personId)) {
                                structure.children[personId].push(rel.personId);
                            }
                            if (!structure.parents[rel.personId].includes(personId)) {
                                structure.parents[rel.personId].push(personId);
                            }
                        } else if (rel.type === 'child-parent') {
                            if (!structure.parents[personId].includes(rel.personId)) {
                                structure.parents[personId].push(rel.personId);
                            }
                            if (!structure.children[rel.personId].includes(personId)) {
                                structure.children[rel.personId].push(personId);
                            }
                        } else if (rel.type === 'spouse') {
                            if (!structure.spouses[personId].includes(rel.personId)) {
                                structure.spouses[personId].push(rel.personId);
                            }
                        }
                    });
                }
            });

            // Find roots - prioritize marked root ancestor, then those without parents
            const currentTree = familyTrees[currentTreeId];
            if (currentTree.rootAncestorId && people[currentTree.rootAncestorId]) {
                structure.roots = [currentTree.rootAncestorId];
            } else {
                // Find people without parents
                Object.keys(people).forEach(personId => {
                    if (structure.parents[personId].length === 0) {
                        structure.roots.push(personId);
                    }
                });

                // If no one without parents (circular relationships), find people with spouses but no parents
                if (structure.roots.length === 0) {
                    Object.keys(people).forEach(personId => {
                        if (structure.spouses[personId].length > 0 && structure.parents[personId].length === 0) {
                            structure.roots.push(personId);
                        }
                    });
                }

                // Last resort: pick the first person
                if (structure.roots.length === 0 && Object.keys(people).length > 0) {
                    structure.roots = [Object.keys(people)[0]];
                }
            }

            return structure;
        }

        function calculateTreePositions(structure, people) {
            const positions = {};
            const nodeWidth = 200;
            const nodeHeight = 120;
            const levelHeight = 200;
            const siblingSpacing = 50;

            // Calculate levels
            const levels = {};
            const visited = new Set();

            function assignLevel(personId, level) {
                if (visited.has(personId)) return;
                visited.add(personId);
                
                if (!levels[level]) levels[level] = [];
                levels[level].push(personId);

                // Assign children to next level
                structure.children[personId].forEach(childId => {
                    assignLevel(childId, level + 1);
                });
            }

            // Start from roots
            structure.roots.forEach(rootId => {
                assignLevel(rootId, 0);
            });

            // Position nodes
            Object.keys(levels).forEach(level => {
                const peopleInLevel = levels[level];
                const totalWidth = peopleInLevel.length * nodeWidth + (peopleInLevel.length - 1) * siblingSpacing;
                const startX = Math.max(100, (1000 - totalWidth) / 2); // Minimum left margin

                peopleInLevel.forEach((personId, index) => {
                    positions[personId] = {
                        x: startX + index * (nodeWidth + siblingSpacing),
                        y: 50 + parseInt(level) * levelHeight,
                        level: parseInt(level)
                    };

                    // Position spouses to the right
                    structure.spouses[personId].forEach((spouseId, spouseIndex) => {
                        if (!positions[spouseId]) { // Only position if not already positioned
                            positions[spouseId] = {
                                x: positions[personId].x + nodeWidth + 20 + (spouseIndex * (nodeWidth + 10)),
                                y: positions[personId].y,
                                level: parseInt(level),
                                isSpouse: true
                            };
                        }
                    });
                });
            });

            return positions;
        }

        function renderTreeNodes(container, positions, people, structure) {
            Object.keys(positions).forEach(personId => {
                const person = people[personId];
                const pos = positions[personId];
                
                const node = document.createElement('div');
                node.className = 'tree-node';
                if (person.isRootAncestor) {
                    node.classList.add('root-ancestor');
                }
                if (focusedPersonId === personId) {
                    node.classList.add('focused');
                }
                
                node.style.left = pos.x + 'px';
                node.style.top = pos.y + 'px';
                node.onclick = () => showPersonDetails(personId);

                const birthYear = person.birthYear || '?';
                const deathYear = person.isAlive ? 'Present' : (person.deathYear || '?');
                
                node.innerHTML = `
                    <h4>${person.name}</h4>
                    <p>${birthYear} - ${deathYear}</p>
                    ${person.sex ? `<p>${person.sex}</p>` : ''}
                    ${person.isAlive ? '<p style="color: #27ae60;">●Living</p>' : ''}
                `;

                container.appendChild(node);
            });
        }

        function renderConnections(container, positions, structure) {
            // Parent-child connections
            Object.keys(structure.children).forEach(parentId => {
                if (!positions[parentId]) return;
                
                structure.children[parentId].forEach(childId => {
                    if (!positions[childId]) return;
                    
                    const parentPos = positions[parentId];
                    const childPos = positions[childId];
                    
                    // Vertical line from parent down
                    const verticalLine = document.createElement('div');
                    verticalLine.className = 'tree-connection parent-child-connection';
                    verticalLine.style.left = (parentPos.x + 90) + 'px';
                    verticalLine.style.top = (parentPos.y + 120) + 'px';
                    verticalLine.style.width = '3px';
                    verticalLine.style.height = Math.abs(childPos.y - parentPos.y - 120) + 'px';
                    container.appendChild(verticalLine);
                    
                    // Horizontal line to child
                    const horizontalLine = document.createElement('div');
                    horizontalLine.className = 'tree-connection parent-child-connection';
                    const leftX = Math.min(parentPos.x + 90, childPos.x + 90);
                    const rightX = Math.max(parentPos.x + 90, childPos.x + 90);
                    horizontalLine.style.left = leftX + 'px';
                    horizontalLine.style.top = (childPos.y - 10) + 'px';
                    horizontalLine.style.width = (rightX - leftX) + 'px';
                    horizontalLine.style.height = '3px';
                    container.appendChild(horizontalLine);
                    
                    // Vertical line to child
                    const childVerticalLine = document.createElement('div');
                    childVerticalLine.className = 'tree-connection parent-child-connection';
                    childVerticalLine.style.left = (childPos.x + 90) + 'px';
                    childVerticalLine.style.top = (childPos.y - 10) + 'px';
                    childVerticalLine.style.width = '3px';
                    childVerticalLine.style.height = '10px';
                    container.appendChild(childVerticalLine);
                });
            });

            // Spouse connections
            Object.keys(structure.spouses).forEach(personId => {
                if (!positions[personId]) return;
                
                structure.spouses[personId].forEach(spouseId => {
                    if (!positions[spouseId] || positions[spouseId].isSpouse) return;
                    
                    const personPos = positions[personId];
                    const spousePos = positions[spouseId];
                    
                    // Horizontal line between spouses
                    const spouseLine = document.createElement('div');
                    spouseLine.className = 'tree-connection spouse-connection';
                    const leftX = Math.min(personPos.x + 180, spousePos.x);
                    const rightX = Math.max(personPos.x + 180, spousePos.x);
                    spouseLine.style.left = leftX + 'px';
                    spouseLine.style.top = (personPos.y + 60) + 'px';
                    spouseLine.style.width = (rightX - leftX) + 'px';
                    spouseLine.style.height = '3px';
                    container.appendChild(spouseLine);
                });
            });
        }            structure.children[personId].push(rel.personId);
                            structure.parents[rel.personId].push(personId);
                        } else if (rel.type === 'child-parent') {
                            structure.parents[personId].push(rel.personId);
                            structure.children[rel.personId].push(personId);
                        } else if (rel.type === 'spouse') {
                            structure.spouses[personId].push(rel.personId);
                        }
                    });
                }
            });

            // Find root people (those without parents)
            Object.keys(people).forEach(personId => {
                if (structure.parents[personId].length === 0) {
                    structure.roots.push(personId);
                }
            });

            return structure;
        }

        function renderFullTree(structure, people) {
            let html = '<div class="tree-levels">';
            
            if (structure.roots.length === 0) {
                return '<p>No root members found. This might indicate circular relationships in the data.</p>';
            }

            // Render each generation level
            const rendered = new Set();
            const queue = [...structure.roots];
            let level = 0;

            while (queue.length > 0 && level < 10) { // Prevent infinite loops
                const currentLevel = [...queue];
                queue.length = 0;
                
                if (currentLevel.length === 0) break;

                html += `<div class="tree-level">`;
                html += `<h3 style="width: 100%; text-align: center; color: #2c3e50; margin-bottom: 1rem;">Generation ${level + 1}</h3>`;
                
                currentLevel.forEach(personId => {
                    if (rendered.has(personId)) return;
                    
                    html += renderPersonNode(people[personId], structure, people);
                    rendered.add(personId);
                    
                    // Add children to next level
                    structure.children[personId].forEach(childId => {
                        if (!rendered.has(childId) && !queue.includes(childId)) {
                            queue.push(childId);
                        }
                    });
                });
                
                html += '</div>';
                level++;
            }

            html += '</div>';
            return html;
        }

        function renderFocusedTree(structure, focusedPersonId, people) {
            let html = '<div class="focused-tree">';
            
            const focusedPerson = people[focusedPersonId];
            html += `<div style="text-align: center; margin-bottom: 2rem;">
                <h3>Family Tree focused on: ${focusedPerson.name}</h3>
            </div>`;

            // Get ancestors (parents, grandparents, etc.)
            const ancestors = getAncestors(focusedPersonId, structure, 3);
            if (ancestors.length > 0) {
                html += '<div class="tree-level">';
                html += '<h4 style="width: 100%; text-align: center; color: #2c3e50;">Ancestors</h4>';
                ancestors.forEach(personId => {
                    html += renderPersonNode(people[personId], structure, people);
                });
                html += '</div>';
            }

            // Render focused person with special styling
            html += '<div class="tree-level">';
            html += '<h4 style="width: 100%; text-align: center; color: #e74c3c;">Focus Person</h4>';
            html += renderPersonNode(focusedPerson, structure, people, true);
            html += '</div>';

            // Get descendants (children, grandchildren, etc.)
            const descendants = getDescendants(focusedPersonId, structure, 3);
            if (descendants.length > 0) {
                html += '<div class="tree-level">';
                html += '<h4 style="width: 100%; text-align: center; color: #2c3e50;">Descendants</h4>';
                descendants.forEach(personId => {
                    html += renderPersonNode(people[personId], structure, people);
                });
                html += '</div>';
            }

            html += '</div>';
            return html;
        }

        function renderPersonNode(person, structure, people, isFocused = false) {
            const spouses = structure.spouses[person.id].map(spouseId => people[spouseId]);
            
            let html = `<div class="tree-node ${isFocused ? 'focused' : ''}" onclick="showPersonDetails('${person.id}')">`;
            html += `<h4>${person.name}</h4>`;
            
            if (person.birthYear || person.deathYear) {
                html += `<p>${person.birthYear || '?'} - ${person.deathYear || 'Present'}</p>`;
            }
            
            if (person.sex) {
                html += `<p>${person.sex}</p>`;
            }
            
            if (spouses.length > 0) {
                html += `<p><strong>Spouse(s):</strong><br>`;
                spouses.forEach(spouse => {
                    html += `${spouse.name}<br>`;
                });
                html += `</p>`;
            }
            
            html += '</div>';
            return html;
        }

        function getAncestors(personId, structure, maxLevels) {
            const ancestors = [];
            const visited = new Set();
            
            function collectAncestors(pid, level) {
                if (level >= maxLevels || visited.has(pid)) return;
                visited.add(pid);
                
                structure.parents[pid].forEach(parentId => {
                    if (!ancestors.includes(parentId)) {
                        ancestors.push(parentId);
                    }
                    collectAncestors(parentId, level + 1);
                });
            }
            
            collectAncestors(personId, 0);
            return ancestors;
        }

        function getDescendants(personId, structure, maxLevels) {
            const descendants = [];
            const visited = new Set();
            
            function collectDescendants(pid, level) {
                if (level >= maxLevels || visited.has(pid)) return;
                visited.add(pid);
                
                structure.children[pid].forEach(childId => {
                    if (!descendants.includes(childId)) {
                        descendants.push(childId);
                    }
                    collectDescendants(childId, level + 1);
                });
            }
            
            collectDescendants(personId, 0);
            return descendants;
        }

        function focusOnPerson() {
            const searchTerm = document.getElementById('tree-search-input').value.trim().toLowerCase();
            if (!searchTerm) return;

            const currentTree = familyTrees[currentTreeId];
            const people = Object.values(currentTree.people);
            
            const matchedPerson = people.find(person => 
                person.name.toLowerCase().includes(searchTerm)
            );

            if (matchedPerson) {
                focusedPersonId = matchedPerson.id;
                renderTree();
            } else {
                alert('Person not found. Please check the name and try again.');
            }
        }

        function showFullTree() {
            focusedPersonId = null;
            renderTree();
        }

        function showPersonDetails(personId) {
            const currentTree = familyTrees[currentTreeId];
            const person = currentTree.people[personId];
            const structure = buildTreeStructure(currentTree.people, currentTree.relationships);
            
            if (!person) return;

            const deathYear = person.isAlive ? 'Living' : (person.deathYear || 'Unknown');
            
            let html = `
                <div class="person-card">
                    <h4>${person.name}</h4>
                    <p><strong>Birth Year:</strong> ${person.birthYear || 'Unknown'}</p>
                    <p><strong>Death Year:</strong> ${deathYear}</p>
                    <p><strong>Sex:</strong> ${person.sex || 'Unknown'}</p>
                    <p><strong>Gothram:</strong> ${person.gothram || 'Unknown'}</p>
                    <p><strong>Birthplace:</strong> ${person.birthplace || 'Unknown'}</p>
                    <p><strong>Occupation:</strong> ${person.occupation || 'Unknown'}</p>
                    ${person.notes ? `<p><strong>Notes:</strong> ${person.notes}</p>` : ''}
                    ${person.isRootAncestor ? '<p><strong>Marked as:</strong> Root Ancestor</p>' : ''}
                </div>
            `;

            // Show relationships
            html += '<h4>Relationships:</h4>';
            
            // Parents
            const parents = structure.parents[personId].map(pid => currentTree.people[pid]);
            if (parents.length > 0) {
                html += '<p><strong>Parents:</strong><br>';
                parents.forEach(parent => {
                    html += `${parent.name}<br>`;
                });
                html += '</p>';
            }

            // Spouses
            const spouses = structure.spouses[personId].map(sid => currentTree.people[sid]);
            if (spouses.length > 0) {
                html += '<p><strong>Spouse(s):</strong><br>';
                spouses.forEach(spouse => {
                    html += `${spouse.name}<br>`;
                });
                html += '</p>';
            }

            // Children
            const children = structure.children[personId].map(cid => currentTree.people[cid]);
            if (children.length > 0) {
                html += '<p><strong>Children:</strong><br>';
                children.forEach(child => {
                    html += `${child.name}<br>`;
                });
                html += '</p>';
            }

            document.getElementById('person-details').innerHTML = html;
            document.getElementById('person-modal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('person-modal').style.display = 'none';
        }

        // Relations finder
        function showRelations() {
            const personId = document.getElementById('relation-search').value;
            if (!personId) return;

            const currentTree = familyTrees[currentTreeId];
            const person = currentTree.people[personId];
            const structure = buildTreeStructure(currentTree.people, currentTree.relationships);

            let html = `<h3>Family Relations for ${person.name}</h3>`;

            // Immediate Family
            html += '<div class="relationship-section">';
            html += '<h3>Immediate Family</h3>';

            // Parents
            const parents = structure.parents[personId];
            if (parents.length > 0) {
                html += '<h4>Parents:</h4>';
                parents.forEach(parentId => {
                    const parent = currentTree.people[parentId];
                    html += `<div class="person-card">
                        <h4>${parent.name}</h4>
                        <p>${parent.birthYear || '?'} - ${parent.deathYear || 'Present'}</p>
                    </div>`;
                });
            }

            // Spouses
            const spouses = structure.spouses[personId];
            if (spouses.length > 0) {
                html += '<h4>Spouse(s):</h4>';
                spouses.forEach(spouseId => {
                    const spouse = currentTree.people[spouseId];
                    html += `<div class="person-card">
                        <h4>${spouse.name}</h4>
                        <p>${spouse.birthYear || '?'} - ${spouse.deathYear || 'Present'}</p>
                    </div>`;
                });
            }

            // Children
            const children = structure.children[personId];
            if (children.length > 0) {
                html += '<h4>Children:</h4>';
                children.forEach(childId => {
                    const child = currentTree.people[childId];
                    html += `<div class="person-card">
                        <h4>${child.name}</h4>
                        <p>${child.birthYear || '?'} - ${child.deathYear || 'Present'}</p>
                    </div>`;
                });
            }

            html += '</div>';

            // Extended Family
            html += '<div class="relationship-section">';
            html += '<h3>Extended Family</h3>';

            // Siblings
            const siblings = getSiblings(personId, structure);
            if (siblings.length > 0) {
                html += '<h4>Siblings:</h4>';
                siblings.forEach(siblingId => {
                    const sibling = currentTree.people[siblingId];
                    html += `<div class="person-card">
                        <h4>${sibling.name}</h4>
                        <p>${sibling.birthYear || '?'} - ${sibling.deathYear || 'Present'}</p>
                    </div>`;
                });
            }

            // Grandparents
            const grandparents = getGrandparents(personId, structure);
            if (grandparents.length > 0) {
                html += '<h4>Grandparents:</h4>';
                grandparents.forEach(grandparentId => {
                    const grandparent = currentTree.people[grandparentId];
                    html += `<div class="person-card">
                        <h4>${grandparent.name}</h4>
                        <p>${grandparent.birthYear || '?'} - ${grandparent.deathYear || 'Present'}</p>
                    </div>`;
                });
            }

            html += '</div>';

            // In-laws (if married)
            if (spouses.length > 0) {
                html += '<div class="relationship-section">';
                html += '<h3>In-Laws</h3>';
                
                spouses.forEach(spouseId => {
                    const spouseParents = structure.parents[spouseId];
                    if (spouseParents.length > 0) {
                        html += '<h4>Parents-in-Law:</h4>';
                        spouseParents.forEach(inLawId => {
                            const inLaw = currentTree.people[inLawId];
                            html += `<div class="person-card">
                                <h4>${inLaw.name}</h4>
                                <p>${inLaw.birthYear || '?'} - ${inLaw.deathYear || 'Present'}</p>
                            </div>`;
                        });
                    }
                });

                html += '</div>';
            }

            document.getElementById('relations-display').innerHTML = html;
        }

        function getSiblings(personId, structure) {
            const siblings = [];
            const parents = structure.parents[personId];
            
            parents.forEach(parentId => {
                structure.children[parentId].forEach(childId => {
                    if (childId !== personId && !siblings.includes(childId)) {
                        siblings.push(childId);
                    }
                });
            });
            
            return siblings;
        }

        function getGrandparents(personId, structure) {
            const grandparents = [];
            const parents = structure.parents[personId];
            
            parents.forEach(parentId => {
                structure.parents[parentId].forEach(grandparentId => {
                    if (!grandparents.includes(grandparentId)) {
                        grandparents.push(grandparentId);
                    }
                });
            });
            
            return grandparents;
        }

        // Tree linking functionality
        function searchAcrossTrees() {
            const searchName = document.getElementById('link-person-name').value.trim().toLowerCase();
            if (!searchName) return;

            const results = [];
            Object.values(familyTrees).forEach(tree => {
                Object.values(tree.people).forEach(person => {
                    if (person.name.toLowerCase().includes(searchName)) {
                        results.push({
                            person: person,
                            treeName: tree.name,
                            treeId: tree.id
                        });
                    }
                });
            });

            let html = '';
            if (results.length === 0) {
                html = '<p>No matches found across all trees.</p>';
            } else if (results.length === 1) {
                html = '<p>Only one person found with that name.</p>';
            } else {
                html = '<h4>Multiple people found. Are any of these the same person?</h4>';
                html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem; margin-top: 1rem;">';
                
                results.forEach((result, index) => {
                    html += `
                        <div class="person-card">
                            <h4>${result.person.name}</h4>
                            <p><strong>Tree:</strong> ${result.treeName}</p>
                            <p><strong>Birth:</strong> ${result.person.birthYear || 'Unknown'}</p>
                            <p><strong>Death:</strong> ${result.person.deathYear || 'Unknown'}</p>
                            <p><strong>Sex:</strong> ${result.person.sex || 'Unknown'}</p>
                            <p><strong>Birthplace:</strong> ${result.person.birthplace || 'Unknown'}</p>
                            <button class="btn btn-secondary" onclick="selectForMerge('${result.treeId}', '${result.person.id}', ${index})">Select for Merge</button>
                        </div>
                    `;
                });
                
                html += '</div>';
                html += '<div style="margin-top: 1rem;"><button class="btn" onclick="mergeTrees()">Merge Selected Trees</button></div>';
            }

            document.getElementById('link-results').innerHTML = html;
        }

        let selectedForMerge = [];

        function selectForMerge(treeId, personId, index) {
            selectedForMerge.push({ treeId, personId, index });
            
            // Update UI to show selection
            const buttons = document.querySelectorAll('#link-results .btn-secondary');
            if (buttons[index]) {
                buttons[index].textContent = 'Selected ✓';
                buttons[index].disabled = true;
                buttons[index].classList.add('btn');
                buttons[index].classList.remove('btn-secondary');
            }
        }

        function mergeTrees() {
            if (selectedForMerge.length < 2) {
                alert('Please select at least 2 people to merge their trees.');
                return;
            }

            if (confirm('This will merge the selected trees. Are you sure?')) {
                // Implementation for merging trees would go here
                // For now, just show a message
                alert('Tree merging functionality will be implemented. For now, you can manually recreate relationships between trees.');
                selectedForMerge = [];
                document.getElementById('link-results').innerHTML = '';
            }
        }

        // Data persistence
        function saveToLocalStorage() {
            try {
                localStorage.setItem('familyTrees', JSON.stringify(familyTrees));
                localStorage.setItem('currentTreeId', currentTreeId);
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }

        function loadFromLocalStorage() {
            try {
                const savedTrees = localStorage.getItem('familyTrees');
                const savedCurrentTreeId = localStorage.getItem('currentTreeId');
                
                if (savedTrees) {
                    familyTrees = JSON.parse(savedTrees);
                }
                if (savedCurrentTreeId) {
                    currentTreeId = savedCurrentTreeId;
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
                familyTrees = {};
                currentTreeId = null;
            }
        }

        function exportData() {
            if (!currentTreeId) return;
            
            const data = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                tree: familyTrees[currentTreeId]
            };
            
            downloadJSON(data, `${familyTrees[currentTreeId].name.replace(/\s+/g, '_')}_family_tree.json`);
            showMessage('save-load-message', 'Current tree exported successfully!', 'success');
        }

        function exportAllData() {
            const data = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                trees: familyTrees
            };
            
            downloadJSON(data, 'all_family_trees.json');
            showMessage('save-load-message', 'All trees exported successfully!', 'success');
        }

        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importData() {
            const fileInput = document.getElementById('import-file');
            const file = fileInput.files[0];
            
            if (!file) {
                showMessage('save-load-message', 'Please select a file to import.', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (data.tree) {
                        // Single tree import
                        const treeId = 'imported_' + Date.now();
                        familyTrees[treeId] = { ...data.tree, id: treeId };
                        currentTreeId = treeId;
                        showMessage('save-load-message', 'Tree imported successfully!', 'success');
                    } else if (data.trees) {
                        // Multiple trees import
                        Object.values(data.trees).forEach(tree => {
                            const treeId = 'imported_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                            familyTrees[treeId] = { ...tree, id: treeId };
                        });
                        currentTreeId = Object.keys(familyTrees)[0];
                        showMessage('save-load-message', 'All trees imported successfully!', 'success');
                    } else {
                        showMessage('save-load-message', 'Invalid file format.', 'error');
                        return;
                    }
                    
                    saveToLocalStorage();
                    updateUI();
                    fileInput.value = '';
                    
                } catch (error) {
                    showMessage('save-load-message', 'Error reading file. Please check the file format.', 'error');
                }
            };
            
            reader.readAsText(file);
        }

        function clearAllData() {
            if (confirm('Are you sure you want to delete ALL family tree data? This cannot be undone.')) {
                familyTrees = {};
                currentTreeId = null;
                focusedPersonId = null;
                localStorage.removeItem('familyTrees');
                localStorage.removeItem('currentTreeId');
                
                // Create default tree
                createNewTree('My Family Tree');
                updateUI();
                showMessage('save-load-message', 'All data cleared successfully.', 'success');
            }
        }

        // Utility functions
        function showMessage(containerId, message, type) {
            const container = document.getElementById(containerId);
            const className = type === 'error' ? 'error-message' : 'success-message';
            container.innerHTML = `<div class="${className}">${message}</div>`;
            
            // Clear message after 5 seconds
            setTimeout(() => {
                container.innerHTML = '';
            }, 5000);
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('person-modal');
            if (event.target === modal) {
                closeModal();
            }
        }

        // Handle file input for import
        document.addEventListener('DOMContentLoaded', function() {
            const fileInput = document.getElementById('import-file');
            fileInput.addEventListener('change', function() {
                if (this.files.length > 0) {
                    const fileName = this.files[0].name;
                    showMessage('save-load-message', `Selected file: ${fileName}`, 'success');
                }
            });
        });
    </script>
</body>
</html>
